

<!doctype html>

<html lang="en">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
    <meta name="robots" content="noindex">
    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
        integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="assets/style.css">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <style>
        map.lessons area {
            background: black;

        }
    </style>

    <title>Lab Escape</title>
</head>

<body>


<div class="nav-wrapper" style="height:80px">
  <div id="navbar">
    <div><img src="assets/img/logo.png" class="py-2  px-4" style="width:140px; float:left;" alt="Lab Escape" /></div>
    <span class="title py-2 px-4" href="#" style="font-size: 32px; float:left;">
      
      
    </span>

    
    

  </div>
    </div>

  <script type="text/javascript">
    // When the user scrolls the page, execute myFunction
    window.onscroll = function() {myFunction()};

    // Get the navbar
    var navbar = document.getElementById("navbar");

    // Get the offset position of the navbar
    var sticky = navbar.offsetTop + 20;

    // Add the sticky class to the navbar when you reach its scroll position. Remove "sticky" when you leave the scroll position
    function myFunction() {
      if (window.pageYOffset >= sticky) {
        navbar.classList.add("sticky")
      } else {
        navbar.classList.remove("sticky");
      }
    }
  </script>


    <div class="container-fluid"  style="">

          

            </div>


            <main role="main" class="w3-rest container-fluid" style="background:#fce3b3; max-width: 1320px; min-width:60%; ">
                <div style="">
                  
                  </section>
                </div>

                <div class="w3-panel mx-auto" style="">
                  
<canvas id="confetti" width="1" height="1"></canvas>

                    
<div class="mx-auto" style="width: 80%;">
    <iframe id = "player" src="https://www.youtube.com/embed/q7mumvUpCMs?enablejsapi=1" width="1024" height="576" frameborder="0"
      allow="autoplay; fullscreen; picture-in-picture" allowfullscreen ></iframe>
</div>
<section class="mx-auto text-left outro w3-panel" style="display: none;  margin-left:25%; width:50%; ">
  <p>
    Super, Ihr habt den Detektor wieder zum Laufen gebracht!<br />
    Vielen Dank, dass Ihr bei unserem Escape-Lab mitgemacht habt. <br />
    Wir hoffen, es hat Euch Spaß gemacht!
  </p>
  <p>
    verbrauchte Zeit: <span id="time_taken"></span>
  </p>
  <a href="javascript:window.open('','_self').close();"
  class="w3-btn w3-blue w3-round-large" style="float:right"> Spiel schließen </a>
</section>

                </div>


                <div class="w3-panel" style="">

                  
                </div>



            </main>





        </div>

    
    
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"
        integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx"
        crossorigin="anonymous"></script>
    <script type="text/javascript" src="jslib/jquery.imagemapster.min.js"></script>
    <script type="text/javascript" src="jslib/scripts.js"></script>
    
    <script type="text/javascript">
      $(function () {
          $('.experiment-popover').popover({
              container: 'body',
              html: true,
              trigger: 'hover',
              title: "",
              content:'Repariert alle wichtigen Komponenten, um das Experiment wieder zum Laufen zu bringen. '
          })
      })
    </script>
    
    
<script>

  var iframe = document.querySelector('iframe');

  // 2. This code loads the IFrame Player API code asynchronously.
  var tag = document.createElement('script');

  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      // 3. This function creates an <iframe> (and YouTube player)
      //    after the API code downloads.
  var player;
  function onYouTubeIframeAPIReady() {
    player = new YT.Player('player',{
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  }

  $().ready(function () {
    start_confetti();
  });

  // 4. The API will call this function when the video player is ready.
  function onPlayerReady(event) {
    event.target.playVideo();
  }
    // 5. The API calls this function when the player's state changes.
        //    The function indicates that when playing a video (state=1),
      //    the player should play for six seconds and then stop.
  function onPlayerStateChange(event) {
    if (event.data == YT.PlayerState.ENDED) {
      setTimeout(stopVideo, 100);
    }
  }
  function stopVideo() {
    $('.outro').show();
    var time_taken = JSON.parse(readCookie('time_taken'));
    var hours = Math.floor((time_taken % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    var minutes = Math.floor((time_taken % (1000 * 60 * 60)) / (1000 * 60));
    var seconds = Math.floor((time_taken % (1000 * 60)) / 1000);

    hours = ("0" + hours).slice(-2);
    minutes = ("0" + minutes).slice(-2);
    seconds = ("0" + seconds).slice(-2);

    document.getElementById("time_taken").innerHTML = hours + ":" + minutes + ":" + seconds;
  }
</script>
<script type="text/javascript">
  var start_confetti = function () {
    var retina = window.devicePixelRatio,

      // Math shorthands
      PI = Math.PI,
      sqrt = Math.sqrt,
      round = Math.round,
      random = Math.random,
      cos = Math.cos,
      sin = Math.sin,

      // Local WindowAnimationTiming interface
      rAF = window.requestAnimationFrame,
      cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame;

    // Local WindowAnimationTiming interface polyfill
    (function (w) {
      /**
      * Fallback implementation.
      */
      var prev = new Date().getTime();
      function fallback(fn) {
        var curr = _now();
        var ms = Math.max(0, 16 - (curr - prev));
        var req = setTimeout(fn, ms);
        prev = curr;
        return req;
      }

      /**
      * Cancel.
      */
      var cancel = w.cancelAnimationFrame
        || w.webkitCancelAnimationFrame
        || w.clearTimeout;

      rAF = w.requestAnimationFrame
        || w.webkitRequestAnimationFrame
        || fallback;

      cAF = function (id) {
        cancel.call(w, id);
      };
    }(window));


    var speed = 50,
      duration = (1.0 / speed),
      confettiRibbonCount = 11,
      ribbonPaperCount = 30,
      ribbonPaperDist = 8.0,
      ribbonPaperThick = 8.0,
      confettiPaperCount = 95,
      DEG_TO_RAD = PI / 180,
      RAD_TO_DEG = 180 / PI,
      colors = [
        ["#df0049", "#660671"],
        ["#00e857", "#005291"],
        ["#2bebbc", "#05798a"],
        ["#ffd200", "#b06c00"]
      ];

    function Vector2(_x, _y) {
      this.x = _x, this.y = _y;
      this.Length = function () {
        return sqrt(this.SqrLength());
      }
      this.SqrLength = function () {
        return this.x * this.x + this.y * this.y;
      }
      this.Add = function (_vec) {
        this.x += _vec.x;
        this.y += _vec.y;
      }
      this.Sub = function (_vec) {
        this.x -= _vec.x;
        this.y -= _vec.y;
      }
      this.Div = function (_f) {
        this.x /= _f;
        this.y /= _f;
      }
      this.Mul = function (_f) {
        this.x *= _f;
        this.y *= _f;
      }
      this.Normalize = function () {
        var sqrLen = this.SqrLength();
        if (sqrLen != 0) {
          var factor = 1.0 / sqrt(sqrLen);
          this.x *= factor;
          this.y *= factor;
        }
      }
      this.Normalized = function () {
        var sqrLen = this.SqrLength();
        if (sqrLen != 0) {
          var factor = 1.0 / sqrt(sqrLen);
          return new Vector2(this.x * factor, this.y * factor);
        }
        return new Vector2(0, 0);
      }
    }
    Vector2.Lerp = function (_vec0, _vec1, _t) {
      return new Vector2((_vec1.x - _vec0.x) * _t + _vec0.x, (_vec1.y - _vec0.y) * _t + _vec0.y);
    }
    Vector2.Distance = function (_vec0, _vec1) {
      return sqrt(Vector2.SqrDistance(_vec0, _vec1));
    }
    Vector2.SqrDistance = function (_vec0, _vec1) {
      var x = _vec0.x - _vec1.x;
      var y = _vec0.y - _vec1.y;
      return (x * x + y * y + z * z);
    }
    Vector2.Scale = function (_vec0, _vec1) {
      return new Vector2(_vec0.x * _vec1.x, _vec0.y * _vec1.y);
    }
    Vector2.Min = function (_vec0, _vec1) {
      return new Vector2(Math.min(_vec0.x, _vec1.x), Math.min(_vec0.y, _vec1.y));
    }
    Vector2.Max = function (_vec0, _vec1) {
      return new Vector2(Math.max(_vec0.x, _vec1.x), Math.max(_vec0.y, _vec1.y));
    }
    Vector2.ClampMagnitude = function (_vec0, _len) {
      var vecNorm = _vec0.Normalized;
      return new Vector2(vecNorm.x * _len, vecNorm.y * _len);
    }
    Vector2.Sub = function (_vec0, _vec1) {
      return new Vector2(_vec0.x - _vec1.x, _vec0.y - _vec1.y, _vec0.z - _vec1.z);
    }

    function EulerMass(_x, _y, _mass, _drag) {
      this.position = new Vector2(_x, _y);
      this.mass = _mass;
      this.drag = _drag;
      this.force = new Vector2(0, 0);
      this.velocity = new Vector2(0, 0);
      this.AddForce = function (_f) {
        this.force.Add(_f);
      }
      this.Integrate = function (_dt) {
        var acc = this.CurrentForce(this.position);
        acc.Div(this.mass);
        var posDelta = new Vector2(this.velocity.x, this.velocity.y);
        posDelta.Mul(_dt);
        this.position.Add(posDelta);
        acc.Mul(_dt);
        this.velocity.Add(acc);
        this.force = new Vector2(0, 0);
      }
      this.CurrentForce = function (_pos, _vel) {
        var totalForce = new Vector2(this.force.x, this.force.y);
        var speed = this.velocity.Length();
        var dragVel = new Vector2(this.velocity.x, this.velocity.y);
        dragVel.Mul(this.drag * this.mass * speed);
        totalForce.Sub(dragVel);
        return totalForce;
      }
    }

    function ConfettiPaper(_x, _y) {
      this.pos = new Vector2(_x, _y);
      this.rotationSpeed = (random() * 600 + 800);
      this.angle = DEG_TO_RAD * random() * 360;
      this.rotation = DEG_TO_RAD * random() * 360;
      this.cosA = 1.0;
      this.size = 5.0;
      this.oscillationSpeed = (random() * 1.5 + 0.5);
      this.xSpeed = 40.0;
      this.ySpeed = (random() * 60 + 50.0);
      this.corners = new Array();
      this.time = random();
      var ci = round(random() * (colors.length - 1));
      this.frontColor = colors[ci][0];
      this.backColor = colors[ci][1];
      for (var i = 0; i < 4; i++) {
        var dx = cos(this.angle + DEG_TO_RAD * (i * 90 + 45));
        var dy = sin(this.angle + DEG_TO_RAD * (i * 90 + 45));
        this.corners[i] = new Vector2(dx, dy);
      }
      this.Update = function (_dt) {
        this.time += _dt;
        this.rotation += this.rotationSpeed * _dt;
        this.cosA = cos(DEG_TO_RAD * this.rotation);
        this.pos.x += cos(this.time * this.oscillationSpeed) * this.xSpeed * _dt
        this.pos.y += this.ySpeed * _dt;
        if (this.pos.y > ConfettiPaper.bounds.y) {
          this.pos.x = random() * ConfettiPaper.bounds.x;
          this.pos.y = 0;
        }
      }
      this.Draw = function (_g) {
        if (this.cosA > 0) {
          _g.fillStyle = this.frontColor;
        } else {
          _g.fillStyle = this.backColor;
        }
        _g.beginPath();
        _g.moveTo((this.pos.x + this.corners[0].x * this.size) * retina, (this.pos.y + this.corners[0].y * this.size * this.cosA) * retina);
        for (var i = 1; i < 4; i++) {
          _g.lineTo((this.pos.x + this.corners[i].x * this.size) * retina, (this.pos.y + this.corners[i].y * this.size * this.cosA) * retina);
        }
        _g.closePath();
        _g.fill();
      }
    }
    ConfettiPaper.bounds = new Vector2(0, 0);

    function ConfettiRibbon(_x, _y, _count, _dist, _thickness, _angle, _mass, _drag) {
      this.particleDist = _dist;
      this.particleCount = _count;
      this.particleMass = _mass;
      this.particleDrag = _drag;
      this.particles = new Array();
      var ci = round(random() * (colors.length - 1));
      this.frontColor = colors[ci][0];
      this.backColor = colors[ci][1];
      this.xOff = (cos(DEG_TO_RAD * _angle) * _thickness);
      this.yOff = (sin(DEG_TO_RAD * _angle) * _thickness);
      this.position = new Vector2(_x, _y);
      this.prevPosition = new Vector2(_x, _y);
      this.velocityInherit = (random() * 2 + 4);
      this.time = random() * 100;
      this.oscillationSpeed = (random() * 2 + 2);
      this.oscillationDistance = (random() * 40 + 40);
      this.ySpeed = (random() * 40 + 80);
      for (var i = 0; i < this.particleCount; i++) {
        this.particles[i] = new EulerMass(_x, _y - i * this.particleDist, this.particleMass, this.particleDrag);
      }
      this.Update = function (_dt) {
        var i = 0;
        this.time += _dt * this.oscillationSpeed;
        this.position.y += this.ySpeed * _dt;
        this.position.x += cos(this.time) * this.oscillationDistance * _dt;
        this.particles[0].position = this.position;
        var dX = this.prevPosition.x - this.position.x;
        var dY = this.prevPosition.y - this.position.y;
        var delta = sqrt(dX * dX + dY * dY);
        this.prevPosition = new Vector2(this.position.x, this.position.y);
        for (i = 1; i < this.particleCount; i++) {
          var dirP = Vector2.Sub(this.particles[i - 1].position, this.particles[i].position);
          dirP.Normalize();
          dirP.Mul((delta / _dt) * this.velocityInherit);
          this.particles[i].AddForce(dirP);
        }
        for (i = 1; i < this.particleCount; i++) {
          this.particles[i].Integrate(_dt);
        }
        for (i = 1; i < this.particleCount; i++) {
          var rp2 = new Vector2(this.particles[i].position.x, this.particles[i].position.y);
          rp2.Sub(this.particles[i - 1].position);
          rp2.Normalize();
          rp2.Mul(this.particleDist);
          rp2.Add(this.particles[i - 1].position);
          this.particles[i].position = rp2;
        }
        if (this.position.y > ConfettiRibbon.bounds.y + this.particleDist * this.particleCount) {
          this.Reset();
        }
      }
      this.Reset = function () {
        this.position.y = -random() * ConfettiRibbon.bounds.y;
        this.position.x = random() * ConfettiRibbon.bounds.x;
        this.prevPosition = new Vector2(this.position.x, this.position.y);
        this.velocityInherit = random() * 2 + 4;
        this.time = random() * 100;
        this.oscillationSpeed = random() * 2.0 + 1.5;
        this.oscillationDistance = (random() * 40 + 40);
        this.ySpeed = random() * 40 + 80;
        var ci = round(random() * (colors.length - 1));
        this.frontColor = colors[ci][0];
        this.backColor = colors[ci][1];
        this.particles = new Array();
        for (var i = 0; i < this.particleCount; i++) {
          this.particles[i] = new EulerMass(this.position.x, this.position.y - i * this.particleDist, this.particleMass, this.particleDrag);
        }
      }
      this.Draw = function (_g) {
        for (var i = 0; i < this.particleCount - 1; i++) {
          var p0 = new Vector2(this.particles[i].position.x + this.xOff, this.particles[i].position.y + this.yOff);
          var p1 = new Vector2(this.particles[i + 1].position.x + this.xOff, this.particles[i + 1].position.y + this.yOff);
          if (this.Side(this.particles[i].position.x, this.particles[i].position.y, this.particles[i + 1].position.x, this.particles[i + 1].position.y, p1.x, p1.y) < 0) {
            _g.fillStyle = this.frontColor;
            _g.strokeStyle = this.frontColor;
          } else {
            _g.fillStyle = this.backColor;
            _g.strokeStyle = this.backColor;
          }
          if (i == 0) {
            _g.beginPath();
            _g.moveTo(this.particles[i].position.x * retina, this.particles[i].position.y * retina);
            _g.lineTo(this.particles[i + 1].position.x * retina, this.particles[i + 1].position.y * retina);
            _g.lineTo(((this.particles[i + 1].position.x + p1.x) * 0.5) * retina, ((this.particles[i + 1].position.y + p1.y) * 0.5) * retina);
            _g.closePath();
            _g.stroke();
            _g.fill();
            _g.beginPath();
            _g.moveTo(p1.x * retina, p1.y * retina);
            _g.lineTo(p0.x * retina, p0.y * retina);
            _g.lineTo(((this.particles[i + 1].position.x + p1.x) * 0.5) * retina, ((this.particles[i + 1].position.y + p1.y) * 0.5) * retina);
            _g.closePath();
            _g.stroke();
            _g.fill();
          } else if (i == this.particleCount - 2) {
            _g.beginPath();
            _g.moveTo(this.particles[i].position.x * retina, this.particles[i].position.y * retina);
            _g.lineTo(this.particles[i + 1].position.x * retina, this.particles[i + 1].position.y * retina);
            _g.lineTo(((this.particles[i].position.x + p0.x) * 0.5) * retina, ((this.particles[i].position.y + p0.y) * 0.5) * retina);
            _g.closePath();
            _g.stroke();
            _g.fill();
            _g.beginPath();
            _g.moveTo(p1.x * retina, p1.y * retina);
            _g.lineTo(p0.x * retina, p0.y * retina);
            _g.lineTo(((this.particles[i].position.x + p0.x) * 0.5) * retina, ((this.particles[i].position.y + p0.y) * 0.5) * retina);
            _g.closePath();
            _g.stroke();
            _g.fill();
          } else {
            _g.beginPath();
            _g.moveTo(this.particles[i].position.x * retina, this.particles[i].position.y * retina);
            _g.lineTo(this.particles[i + 1].position.x * retina, this.particles[i + 1].position.y * retina);
            _g.lineTo(p1.x * retina, p1.y * retina);
            _g.lineTo(p0.x * retina, p0.y * retina);
            _g.closePath();
            _g.stroke();
            _g.fill();
          }
        }
      }
      this.Side = function (x1, y1, x2, y2, x3, y3) {
        return ((x1 - x2) * (y3 - y2) - (y1 - y2) * (x3 - x2));
      }
    }
    ConfettiRibbon.bounds = new Vector2(0, 0);
    confetti = {};
    confetti.Context = function (id) {
      var i = 0;
      var canvas = document.getElementById(id);
      var canvasParent = canvas.parentNode;
      var canvasWidth = canvasParent.offsetWidth;
      var canvasHeight = canvasParent.offsetHeight;
      canvas.width = canvasWidth * retina;
      canvas.height = canvasHeight * retina;
      var context = canvas.getContext('2d');
      var interval = null;
      var confettiRibbons = new Array();
      ConfettiRibbon.bounds = new Vector2(canvasWidth, canvasHeight);
      for (i = 0; i < confettiRibbonCount; i++) {
        confettiRibbons[i] = new ConfettiRibbon(random() * canvasWidth, -random() * canvasHeight * 2, ribbonPaperCount, ribbonPaperDist, ribbonPaperThick, 45, 1, 0.05);
      }
      var confettiPapers = new Array();
      ConfettiPaper.bounds = new Vector2(canvasWidth, canvasHeight);
      for (i = 0; i < confettiPaperCount; i++) {
        confettiPapers[i] = new ConfettiPaper(random() * canvasWidth, random() * canvasHeight);
      }
      this.resize = function () {
        canvasWidth = canvasParent.offsetWidth;
        canvasHeight = canvasParent.offsetHeight;
        canvas.width = canvasWidth * retina;
        canvas.height = canvasHeight * retina;
        ConfettiPaper.bounds = new Vector2(canvasWidth, canvasHeight);
        ConfettiRibbon.bounds = new Vector2(canvasWidth, canvasHeight);
      }
      this.start = function () {
        this.stop()
        var context = this;
        this.update();
      }
      this.stop = function () {
        cAF(this.interval);
      }
      this.update = function () {
        var i = 0;
        context.clearRect(0, 0, canvas.width, canvas.height);
        for (i = 0; i < confettiPaperCount; i++) {
          confettiPapers[i].Update(duration);
          confettiPapers[i].Draw(context);
        }
        for (i = 0; i < confettiRibbonCount; i++) {
          confettiRibbons[i].Update(duration);
          confettiRibbons[i].Draw(context);
        }
        this.interval = rAF(function () {
          confetti.update();
        });
      }
    }
    var confetti = new confetti.Context('confetti');
    confetti.start();
    window.addEventListener('resize', function (event) {
      confetti.resize();
    });



  }
</script>

</body>

</html>